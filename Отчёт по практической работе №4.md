##**Отчет по практической работе №4**
______________________________________________________________________________________________

**Цель работы:**изучение методов работы компонентов PWA приложений.

**Задание:** ответить на вопросы, реализовать задание по localStorage, sessionStorage,
дополнить разработанное приложение push уведомлениями  

**1 Service Worker**

При выполнении данного задания была изучена работа Service Worker, в том числе с помощью тестового приложения sw-test, а так же были даны ответы на вопросы, указанные ниже.

- Какие технологии лежат в основе Service Worker?
Service worker — это событийно-управляемый worker, регистрируемый на уровне источника и пути. Он представляет собой JavaScript-файл, который управляет веб-страницей/сайтом, с которым он ассоциируется, перехватывает и модифицирует запросы навигации и ресурсов, очень гибко кеширует ресурсы, для того чтобы предоставить полный контроль над тем, как приложение ведет себя в определенных ситуациях.

- Как работает Service Worker?

Service worker запускается в контексте worker'ов, поэтому он не имеет доступа к DOM и работает в потоке отдельном от основного потока JavaScript, управляющего вашим приложением, а следовательно — не блокирует его. Он призван быть полностью асинхронным; как следствие, синхронные API, такие как XHR и localStorage, в Service Worker'е использовать нельзя.

Из соображений безопасности service worker'ы работают только по HTTPS (либо, в целях разработки, на localhost). Давать сторонним людям возможность измененять сетевые запросы крайне опасно. Кроме того, Service Worker API недоступен в режиме приватного просмотра браузера Firefox.

Service worker сначала регистрируется с помощью метода ServiceWorkerContainer.register(). В случае успешной регистрации, service worker будет загружен клиентом и попытается установиться/активироваться для всех URL, доступных пользователю, или только для указанного подмножества. Service Worker будет следовать следующему жизненному циклу:

  1.Загрузка;
  2.Установка;
  3.Активация.

- Возможно ли проксирование запросов с разных удаленных серверов с разными IP адресами? Почему и как можно реализовать?

Service Worker работает с тем адресом, с которого загружен его код. То есть можно перехватывать только запросы к своему домену. Возможно, реализовать такое можно, используя Cross-Origin worker'a.

- Сохраняется ли проксированный контент? Как настроить сохранение запросов в ServiceWoker?

Данные сохраняются в кеше до того момента, пока не будут удалены. Для кэширования следует использовать встроенный API хранилища Service Worker — cache — глобальный для всех сервис-воркеров, который позволяет хранить результаты запросов.

- Какие есть ограничения в работе Service Woker?

  1.Работает только на localhost домене или же на доменах с SSL поддержкой (или другими словами        сайтами с поддержкой HTTPS);
  2.Не совместим с некоторыми браузерами.

**2 IndexedDB**

При выполнении данного задания было проведено ознакомление с IndexedDB и составлены ответы на вопросы представленные ниже.

- Каким типом хранилища является IndexedDB? 

IndexedDB является стандартом хранения структурированных данных на стороне клиента. Это хранилище ключей/значений (база данных noSQL), которое считается окончательным решением для хранения данных в браузерах. IndexedDB является асинхронным API. Это означает, что выполнение приоритетных операций не будет блокировать поток пользовательского интерфейса. IndexedDB может хранить неопределенный объем данных, который зависит от пользователя.  

- Какая последовательность работы с хранилищем?

Обычная последовательность шагов при работе с IndexedDB :

  1.Открыть базу данных.
  2.Создать хранилище объектов в базе данных, над которой будут выполняться наши операции. 
  3.Запустить транзакцию и выдать запрос на выполнение какой-либо операции с базой данных,   например, добавление или извлечение данных.
  4.Ждать завершения операции, “слушая” событие DOM, на которое должен быть установлен наш   обработчик.
  5.Сделать что-то с результатами (которые могут быть найдены в возвращаемом по нашему запросу   объекте).

- Какой жизненный цикл хранилища?

  1.Открытие БД
  2.Создание хранилища
  3.Работа
  4.Удаление хранилища
  5.Удаление БД

- Будет ли доступна информация из хранилища при закрытии веб-приложения? Если нет – какой тип хранилища надо использовать?

Информация из хранилища при закрытии веб-приложения будет доступна, так как информация храниться в  локальной БД и при отсутствии сети пользователь может в любой момент получить сохраненные данные.

- Будет ли доступно хранилище двум одновременно открытым экземплярам веб-приложения? Почему?

IndexedDB гарантирует атомарность транзакций и является ассинхронным хранилищем, что позволяет поддерживать доступность хранилища двум и более одновременно открытым экземплярам приложения.

**3 LocalStorage, sessionStorage**

В ходе выполнения данного задания проведено ознакомление с LocalStorage, sessionStorage. После чего были 
даны ответы на предлагаемые вопросы и выполнено задание: «Создайте поле textarea, значение которого будет автоматически сохраняться при каждом его изменении. Когда пользователь закроет страницу и потом откроет её заново он должен увидеть последнее введённое значение.» Код задания находится в ветке [ToolsPWApplication](https://github.com/PlotnikovAndrey/ToolsPWApplication).

- Каким типом хранилища является LocalStorage и sessionStorage?

LocalStorage и sessionStorage хранят данные в браузере по типу ключ/значение.

- Какая последовательность работы с хранилищем?

  1.Сохранить пару/ключ значение: setItem(key, value); 
  2.Получить данные по ключу key: getItem(key); 
  3.Удалить данные по ключу key: removeItem(key), полная очистка с помощью метода clear().

- Какой жизненный цикл хранилища?

Данные записанные в sessionStorage, сохраняются после обновления страницы, а данные, записанные в localStorage - даже после перезапуска браузера или ОС.

- Будет ли доступна информация из хранилища при закрытии веб-приложения? Если нет – какой тип хранилища надо использовать?

Информация будет доступна в localStorage, поскольку она сохраняется после перезапуска браузера и даже ОС. Информация, записанная в sessionStorage, не сохраняется после закрытия приложения. 

- Будет ли доступно хранилище двум одновременно открытым экземплярам веб-приложения? Почему?

Будет поскольку хранилище привязывается к источнику (домен/протокол/порт).

**4 Push Notification**

В ходе выполнения задания была изучена работа push уведомлений, после чего ими было дополнено разработанное приложение в практическом задании согласно следующих требований к ним:

   1.Случайное время уведомления;
   2.Случайный текст на уведомлении;
   3.Уведомления являются периодичными;
   4.Уведомления хранятся локально.

Код находится в ветке [ToolsPWApplication](https://github.com/PlotnikovAndrey/ToolsPWApplication).

Пример push уведомления, а также локальное хранение уведомлений продемонстрировано на рисунках ниже.
![Push уведомление](C:\Users\louwe\OneDrive\Рабочий стол\3 КУРС 2 СЕМЕСТР\ИСИС\Картинка1.jpg)

![Локальное хранение уведомлений](C:\Users\louwe\OneDrive\Рабочий стол\3 КУРС 2 СЕМЕСТР\ИСИС\Картинка2.jpg)

